<NAME=not><N=1...32>:

output: out <N>
input: in <N>

output=<NAME>*<N> input



<NAME=nand,and,or,xor,nor,andnot><N=1...32>:

output: out <N>
inputA: in <N>
inputB: in <N>

output=<NAME>*<N> inputA inputB



notP<P=0...24>:

output: out <2**P>
input: in <2**P>

output=not*<2**P> input



<NAME=nand,and,or,xor,nor,andnot>P<P=0...24>:

output: out <2**P>
inputA: in <2**P>
inputB: in <2**P>

output=<NAME>*<2**P> inputA inputB



<NAME=andABC,orABC,xorABC><N=1...32>:

output: out <N>
inputA: in <N>
inputB: in <N>
inputC: in <N>

output=<NAME>*<N> inputA inputB inputC



not:

o: out
i: in

o=nand i i



and:

o: out
ia: in
ib: in

a=nand ia ib
o=not a



or:

o: out
ia: in
ib: in

a=not ia
b=not ib
o=nand a b



xor:

o: out
ia: in
ib: in

a=nand ia ib
b=nand a ia
c=nand a ib
o=nand b c



nor:

o: out
ia: in
ib: in

a=or ia ib
o=not a



andnot:

o: out
ia: in
ib: in

ib_not=not ib
o=and ia ib_not



<NAME=and,or,xor>ABC:

o: out

ia: in
ib: in
ic: in

a=<NAME> ia ib
o=<NAME> a ic



add1:

o: out
o_carry: out

ia: in
ib: in
ic: in

o=xorABC ia ib ic

a=not ia
b=andABC a ib ic
c=or ib ic
d=and ia c
o_carry=or b d



add<N=2...32>:

o: out <N>
o_carry: out

ia: in <N>
ib: in <N>
i_carry: in

a carry=add<N-1> ia[0:<N-1>] ib[0:<N-1>] i_carry
b o_carry=add1 ia[<N-1>] ib[<N-1>] carry
o=set<N> a+b



inc1:

o: out
o_carry: out

i: in
i_carry: in

a=or i i_carry
b=nand i i_carry
o=and a b
o_carry=not b



inc<N=2...32>:

o: out <N>
o_carry: out

i: in <N>
i_carry: in

a carry=inc<N-1> i[0:<N-1>] i_carry
b o_carry=inc1 i[<N-1>] carry
o=set<N> a+b



notzero1:

o: out

i: in

o=set i



notzero<S=2...32>:

o: out

i: in <S>

a=notzero<S-1> i[0:<S-1>]
o=or a i[<S-1>]



notzeroP0:

o: out

i: in

o=set i



notzeroP<SIZEP=1...24>:

o: out

i: in <2**SIZEP>

a=notzeroP<SIZEP-1> i[0:<2**SIZEP/2>]
b=notzeroP<SIZEP-1> i[<2**SIZEP/2>:<2**SIZEP>]
o=or a b



bitShiftLeft<N=1...31>_<S=2...32>:
<?(N<S)>

o: out <S>
o_overflow: out

i: in <S>

a=set<S-N> i[0:<S-N>]
b=set<N> i[<S-N>:<S>]
o=concat<N>_<S-N> 0 a
o_overflow=notzero<N> b



bitShiftRightUnsigned<N=1...31>_<S=2...32>:
<?(N<S)>

o: out <S>
o_overflow: out

i: in <S>

a=set<S-N> i[<N>:<S>]
b=set<N> i[0:<N>]
o=concat<S-N>_<N> a 0
o_overflow=notzero<N> b



bitShiftRightSigned<N=1...31>_<S=2...32>:
<?(N<S)>

o: out <S>
o_overflow: out

i: in <S>

a=set<S-N> i[<N>:<S>]
b=set<N> i[0:<N>]
o=concat<S-N>_<N> a i[<S-1>]*<N>
o_overflow=notzero<N> b



bitShiftLeftP<NP=0...23>_P<SP=1...24>:
<?(NP<SP)>

o: out <2**SP>
o_overflow: out

i: in <2**SP>

a=set<2**SP-2**NP> i[0:<2**SP-2**NP>]
b=set<2**NP> i[<2**SP-2**NP>:<2**SP>]
o=concat<2**NP>_<2**SP-2**NP> 0 a
o_overflow=notzeroP<NP> b



bitShiftRightUnsignedP<NP=0...23>_P<SP=1...24>:
<?(NP<SP)>

o: out <2**SP>
o_overflow: out

i: in <2**SP>

a=set<2**SP-2**NP> i[<2**NP>:<2**SP>]
b=set<2**NP> i[0:<2**NP>]
o=concat<2**SP-2**NP>_<2**NP> a 0
o_overflow=notzeroP<NP> b



bitShiftRightSignedP<NP=0...23>_P<SP=1...24>:
<?(NP<SP)>

o: out <2**SP>
o_overflow: out

i: in <2**SP>

a=set<2**SP-2**NP> i[<2**NP>:<2**SP>]
b=set<2**NP> i[0:<2**NP>]
o=concat<2**SP-2**NP>_<2**NP> a i[<2**SP-1>]*<2**NP>
o_overflow=notzeroP<NP> b



<NAME=bitShiftLeft,bitShiftRightUnsigned,bitShiftRightSigned>N_P<SP=1...24>_step<T=0>:

o: out <2**SP>
o_overflow: out

i: in <2**SP>
i_shift: in <SP>
i_shift_not: in <SP>

b b_overflow=<NAME>P<T>_P<SP> i
o=selector*<2**SP> i_shift_not[<T>]*<2**SP> i_shift[<T>]*<2**SP> i b
o_overflow=and i_shift[<T>] b_overflow



<NAME=bitShiftLeft,bitShiftRightUnsigned,bitShiftRightSigned>N_P<SP=1...24>_step<T=1...23>:
<?(T<SP)>

o: out <2**SP>
o_overflow: out

i: in <2**SP>
i_shift: in <SP>
i_shift_not: in <SP>

a a_overflow=<NAME>N_P<SP>_step<T-1> i i_shift i_shift_not
b b_overflow=<NAME>P<T>_P<SP> a
o=selector*<2**SP> i_shift_not[<T>]*<2**SP> i_shift[<T>]*<2**SP> a b
c_overflow=or a_overflow b_overflow
o_overflow=selector i_shift_not[<T>] i_shift[<T>] a_overflow c_overflow



<NAME=bitShiftLeft,bitShiftRightUnsigned,bitShiftRightSigned>N_P<SP=1...24>_preComputedData:

o: out <2**SP>
o_overflow: out

i: in <2**SP>
i_shift: in <SP>
i_shift_not: in <SP>

o o_overflow=<NAME>N_P<SP>_step<SP-1> i i_shift i_shift_not



<NAME=bitShiftLeft,bitShiftRightUnsigned,bitShiftRightSigned>N_P<SP=1...24>:

o: out <2**SP>
o_overflow: out

i: in <2**SP>
i_shift: in <SP>

shift_not=not*<SP> i_shift
o o_overflow=<NAME>N_P<SP>_preComputedData i i_shift shift_not



wordShift<DIR=Left,RightUnsigned,RightSigned>N_P<SIZEP=1...24>_wordP<WORDP=0...6>:
<?(SIZEP+WORDP<=24)>

o: out <2**(SIZEP+WORDP)>

i_value: in <2**(SIZEP+WORDP)>
i_shift: in <SIZEP>

shift_not=not<SIZEP> i_shift
value=set<2**(SIZEP+WORDP)> i_value%<2**WORDP>
_o _=bitShift<DIR>N_P<SIZEP>_preComputedData*<2**WORDP> value i_shift*<2**WORDP> shift_not*<2**WORDP>
o=set<2**(SIZEP+WORDP)> _o%<2**SIZEP>



neg<N=1...32>:

o: out <N>

i: in <N>

a=not*<N> i
o b=inc<N> a 1



sub<N=1...32>:

o: out <N>
o_carry: out

ia: in <N>
ib: in <N>
i_carry: in

b=neg<N> ib
o o_carry=add<N> ia b i_carry



mul<S=1...32>_1:

o: out <S>
o_overflow: out

ia: in <S>
ib: in

o=and*<S> ia ib*<S>
o_overflow=set 0



mul<S=2...32>_<N=2...32>:
<?(S>=N)>

o: out <S>
o_overflow: out

ia: in <S>
ib: in <N>

a oa=mul<S>_<N-1> ia ib[0:<N-1>]
b _=mul<S>_1 ia ib[<N-1>]
c ob=bitShiftLeft<N-1>_<S> b
o oc=add<S> a c 0
o_overflow=orABC oa ob oc



different1:

o: out

ia: in
ib: in

o=xor ia ib



different<S=2...32>:

o: out

ia: in <S>
ib: in <S>

a=different<S-1> ia[0:<S-1>] ib[0:<S-1>]
b=different1 ia[<S-1>] ib[<S-1>]
o=or a b



equal<S=1...32>:

o: out

ia: in <S>
ib: in <S>

a=different<S> ia ib
o=not a



lessThanUnsigned1:

o: out

ia: in
ib: in

o=andnot ib ia



lessThanUnsigned<S=2...32>:

o: out

ia: in <S>
ib: in <S>

a=lessThanUnsigned<S-1> ia[0:<S-1>] ib[0:<S-1>]
b=lessThanUnsigned1 ia[<S-1>] ib[<S-1>]
c=xor ia[<S-1>] ib[<S-1>]
o=multiplexer c a b



lessThanSigned<S=2...32>:

o: out

ia: in <S>
ib: in <S>

bothNegative_not=nand ia[<S-1>] ib[<S-1>]
bothNegative=not bothNegative_not
differentSigns=xor ia[<S-1>] ib[<S-1>]
ia_not=not*<S> ia
ib_not=not*<S> ib
a=selector*<S-1> bothNegative_not*<S-1> bothNegative*<S-1> ia[0:<S-1>] ia_not[0:<S-1>]
b=selector*<S-1> bothNegative_not*<S-1> bothNegative*<S-1> ib[0:<S-1>] ib_not[0:<S-1>]
c=lessThanUnsigned<S-1> a b
o=multiplexer differentSigns c ia[<S-1>]



divUnsigned<S=2...32>_step<BIT=0...31>:
<?(S>BIT)>

outputQuotientBit: out
outputRemainder: out <S>

inputDividend: in <S>
inputDivisor: in <S>
inputDivisorNeg: in <S>
inputRemainder: in <S>

a=concat1_<S-1> inputDividend[<BIT>] inputRemainder[0:<S-1>]
b _=add<S> a inputDivisorNeg 0
bit=lessThanUnsigned<S> a inputDivisor
outputQuotientBit=not bit
outputRemainder=ternaryOperator<S> bit b a



divUnsigned<S=2...32>_stepsToBit<BIT=2...32>:
<?(S==BIT)>

outputQuotient: out <S>
outputRemainder: out <S>

inputDividend: in <S>
inputDivisor: in <S>
inputDivisorNeg: in <S>

outputQuotient=set<S> 0
outputRemainder=set<S> 0



divUnsigned<S=2...32>_stepsToBit<BIT=0...31>:
<?(S>BIT)>

outputQuotient: out <S>
outputRemainder: out <S>

inputDividend: in <S>
inputDivisor: in <S>
inputDivisorNeg: in <S>

quotient remainder=divUnsigned<S>_stepsToBit<BIT+1> inputDividend inputDivisor inputDivisorNeg
quotientNewBit outputRemainder=divUnsigned<S>_step<BIT> inputDividend inputDivisor inputDivisorNeg remainder
outputQuotient=concat1_<S-1> quotientNewBit quotient[0:<S-1>]



divUnsigned<S=2...32>:

outputQuotient: out <S>
outputRemainder: out <S>

inputDividend: in <S>
inputDivisor: in <S>

inputDivisorNeg=neg<S> inputDivisor
outputQuotient outputRemainder=divUnsigned<S>_stepsToBit0 inputDividend inputDivisor inputDivisorNeg



abs<S=1...32>:

o: out <S>

i: in <S>

negated=neg<S> i
i_lastbit_not=not i[<S-1>]
o=selector*<S> i_lastbit_not*<S> i[<S-1>]*<S> i negated



divSigned<S=2...32>:

outputQuotient: out <S>
outputRemainder: out <S>

inputDividend: in <S>
inputDivisor: in <S>

dividend=abs<S> inputDividend
divisor=abs<S> inputDivisor
quotient remainder=divUnsigned<S> dividend divisor
quotientNeg=neg<S> quotient
remainderNeg=neg<S> remainder
outputQuotientSign=xor inputDividend[<S-1>] inputDivisor[<S-1>]
outputQuotient=ternaryOperator<S> outputQuotientSign quotient quotientNeg
outputRemainder=ternaryOperator<S> inputDividend[<S-1>] remainder remainderNeg



fanOut<N=1...32>:

output: out <N>

input: in

output=set<N> input*<N>



fanOutP<N=0...24>:

output: out <2**N>

input: in

output=set<2**N> input*<2**N>



decoder1_preComputedData:

o: out 2

i: in
i_not: in

o=set2 i_not+i



decoder<SP=2...24>_preComputedData:

o: out <2**SP>

i: in <SP>
i_not: in <SP>

previousLevel=decoder<SP-1>_preComputedData i[0:<SP-1>] i_not[0:<SP-1>]
a=selector*<2**SP/2> i_not[<SP-1>]*<2**SP/2> i[<SP-1>]*<2**SP/2> previousLevel 0
b=selector*<2**SP/2> i_not[<SP-1>]*<2**SP/2> i[<SP-1>]*<2**SP/2> 0 previousLevel
o=set<2**SP> a+b



decoder<SP=1...24>:

o: out <2**SP>

i: in <SP>

i_not=not*<SP> i
o=decoder<SP>_preComputedData i i_not



multiplexer:

o: out

i_control: in
ia: in
ib: in

i_control_not=not i_control
o=selector i_control_not i_control ia ib



ternaryOperator<S=1...32>:

o: out <S>

i_control: in
ia: in <S>
ib: in <S>

i_control_not=not i_control
o=selector*<S> i_control_not*<S> i_control*<S> ia ib



ternaryOperatorP<SP=0...16>:

o: out <2**SP>

i_control: in
ia: in <2**SP>
ib: in <2**SP>

i_control_not=not i_control
o=selector*<2**SP> i_control_not*<2**SP> i_control*<2**SP> ia ib



multiplexer1_preComputedData:

o: out

i_control_not: in
i_control: in
i: in 2

o=selector i_control_not i_control i[0] i[1]



multiplexer<SP=2...24>_preComputedData:

o: out

i_control_not: in <SP>
i_control: in <SP>
i: in <2**SP>

a=multiplexer<SP-1>_preComputedData i_control_not[0:<SP-1>] i_control[0:<SP-1>] i[0:<2**SP/2>]
b=multiplexer<SP-1>_preComputedData i_control_not[0:<SP-1>] i_control[0:<SP-1>] i[<2**SP/2>:<2**SP>]
o=selector i_control_not[<SP-1>] i_control[<SP-1>] a b



multiplexer<SP=1...24>:

o: out

i_control: in <SP>
i: in <2**SP>

i_control_not=not*<SP> i_control
o=multiplexer<SP>_preComputedData i_control_not i_control i



chooseAB<S=1...32>:

output: out <S>

inputControl: in
inputA: in <S>
inputB: in <S>

output=ternaryOperator<S> inputControl inputA inputB



chooseABCD<S=1...16>:

output: out <S>

inputControl: in 2
inputA: in <S>
inputB: in <S>
inputC: in <S>
inputD: in <S>

a=chooseAB<S> inputControl[0] inputA inputB
b=chooseAB<S> inputControl[0] inputC inputD
output=chooseAB<S> inputControl[1] a b



chooseABCDEFGH<S=1...16>:

output: out <S>

inputControl: in 3
inputA: in <S>
inputB: in <S>
inputC: in <S>
inputD: in <S>
inputE: in <S>
inputF: in <S>
inputG: in <S>
inputH: in <S>

a=chooseABCD<S> inputControl[0:2] inputA inputB inputC inputD
b=chooseABCD<S> inputControl[0:2] inputE inputF inputG inputH
output=chooseAB<S> inputControl[2] a b



<NAME=or,and,xor>ABCD:

output: out

inputA: in
inputB: in
inputC: in
inputD: in

a=<NAME>ABC inputA inputB inputC
output=<NAME> a inputD



<NAME=or,and,xor>ABCDE:

output: out

inputA: in
inputB: in
inputC: in
inputD: in
inputE: in

a=<NAME>ABCD inputA inputB inputC inputD
output=<NAME> a inputE



<NAME=or,and,xor>ABCDEF:

output: out

inputA: in
inputB: in
inputC: in
inputD: in
inputE: in
inputF: in

a=<NAME>ABCDE inputA inputB inputC inputD inputE
output=<NAME> a inputF



<NAME=or,and,xor>ABCDEFG:

output: out

inputA: in
inputB: in
inputC: in
inputD: in
inputE: in
inputF: in
inputG: in

a=<NAME>ABCDEF inputA inputB inputC inputD inputE inputF
output=<NAME> a inputG



andorand:

o: out

a: in
b: in
c: in
d: in

r1=nand a b
r2=nand c d
o=nand r1 r2



selector:

o: out

i_select_a: in
i_select_b: in
i_a: in
i_b: in

a=nand i_select_a i_a
b=nand i_select_b i_b
o=nand a b



selectorP<SP=0...24>:

o: out <2**SP>

i_select_a: in <2**SP>
i_select_b: in <2**SP>
i_a: in <2**SP>
i_b: in <2**SP>

o=selector*<2**SP> i_select_a i_select_b i_a i_b



deselector:

o_a: out
o_b: out
o_a_not: out
o_b_not: out

i_set_a: in
i_set_b: in
i_value: in

a_not=nand i_set_a i_value
b_not=nand i_set_b i_value
o_a=not a_not
o_b=not b_not
o_a_not=set a_not
o_b_not=set b_not



deselectorP<SP=0...24>:

o_a: out <2**SP>
o_b: out <2**SP>
o_a_not: out <2**SP>
o_b_not: out <2**SP>

i_set_a: in <2**SP>
i_set_b: in <2**SP>
i_value: in <2**SP>

o_a o_b o_a_not o_b_not=deselector*<2**SP> i_set_a i_set_b i_value



demultiplexer1_preComputedData:

o: out 2
o_not: out 2

i_index_not: in
i_index: in
i_value: in

oa ob oa_not ob_not=deselector i_index_not i_index i_value
o=set2 oa+ob
o_not=set2 oa_not+ob_not



demultiplexer<SP=2...24>_preComputedData:

o: out <2**SP>
o_not: out <2**SP>

i_index_not: in <SP>
i_index: in <SP>
i_value: in

a a_not=demultiplexer<SP-1>_preComputedData i_index_not[1:<SP>] i_index[1:<SP>] i_value
o o_not=demultiplexer1_preComputedData*<2**SP/2> i_index_not[0]*<2**SP/2> i_index[0]*<2**SP/2> a



demultiplexer<SP=1...24>:

o: out <2**SP*2>

i_index: in <SP>
i_value: in

i_index_not=not*<SP> i_index
o o_not=demultiplexer<SP>_preComputedData i_index_not i_index i_value



ornor_negInputs:

o_or: out
o_nor: out

i_a_not: in
i_b_not: in

a=nand i_a_not i_b_not
o_or=set a
o_nor=not a



ornor_negInputsP<SP=0...24>:

o_or: out <2**SP>
o_nor: out <2**SP>

i_a_not: in <2**SP>
i_b_not: in <2**SP>

o_or o_nor=ornor_negInputs*<2**SP> i_a_not i_b_not



bitTransposeP<SP=0...24>_wordP<IWORDP=0...24>:
<?(IWORDP<=SP)>

o: out <2**SP>

i: in <2**SP>

o=set<2**SP> i%<2**IWORDP>



fanOutBitwiseP<BP=0...24>_P0:

o: out <2**BP>

i: in

o=set<2**BP> i*<2**BP>



fanOutBitwiseP<BP=0...24>_P<IP=1...24>:
<?(BP+IP<=24)>

o: out <2**(IP+BP)>

i: in <2**IP>

a=fanOutBitwiseP<BP>_P<IP-1> i[0:<2**IP/2>]
b=fanOutBitwiseP<BP>_P<IP-1> i[<2**IP/2>:<2**IP>]
o=set<2**(IP+BP)> a+b



selectorChainP<SIZEP=1...24>_P<RP=0...22>:
<?(RP<SIZEP)>

o: out <2**RP>

i_index_not: in <SIZEP-RP>
i_index: in <SIZEP-RP>
i_array: in <2**SIZEP>

array_transposed=set<2**SIZEP> i_array%<2**RP>
o=multiplexer<SIZEP-RP>_preComputedData*<2**RP> i_index_not*<2**RP> i_index*<2**RP> array_transposed



deselectorChainP<SIZEP=1...24>_P<WP=0...22>:
<?(WP<SIZEP)>

o: out <2**SIZEP>
o_not: out <2**SIZEP>

i_index_not: in <SIZEP-WP>
i_index: in <SIZEP-WP>
i_value: in <2**WP>

_o _o_not=demultiplexer<SIZEP-WP>_preComputedData*<2**WP> i_index_not*<2**WP> i_index*<2**WP> i_value
o=set<2**SIZEP> _o%<2**(SIZEP-WP)>
o_not=set<2**SIZEP> _o_not%<2**(SIZEP-WP)>



arrayIndexReadP<SIZEP=1...24>_P<RP=0...22>:
<?(RP<SIZEP)>

o: out <2**RP>

i_array: in <2**SIZEP>
i_index: in <SIZEP-RP>

index_not=not<SIZEP-RP> i_index
o=selectorChainP<SIZEP>_P<RP> index_not i_index i_array



arrayIndexWriteP<SIZEP=1...24>_P<WP=0...22>:
<?(WP<SIZEP)>

o_write_value: out <2**SIZEP>
o_write_value_not: out <2**SIZEP>
o_write_mask: out <2**SIZEP>
o_write_mask_not: out <2**SIZEP>

i_write_index: in <SIZEP-WP>
i_write_mask: in <2**WP>
i_write_value: in <2**WP>

write_index_not=not<SIZEP-WP> i_write_index

o_write_mask o_write_mask_not=deselectorChainP<SIZEP>_P<WP> write_index_not i_write_index i_write_mask
o_write_value o_write_value_not=deselectorChainP<SIZEP>_P<WP> write_index_not i_write_index i_write_value



addressableMemoryP<SIZEP=1...24>_P<RP=0...10>_P<WP=0...10>:
<?(RP<SIZEP)>
<?(WP<SIZEP)>

o_read_value: out <2**RP>

i_read_address: in <SIZEP-RP>
i_write_mask: in <2**WP>
i_write_address: in <SIZEP-WP>
i_write_value: in <2**WP>

memory: reg <2**SIZEP>

o_read_value=arrayIndexReadP<SIZEP>_P<RP> memory i_read_address

write_value write_value_not write_mask write_mask_not=arrayIndexWriteP<SIZEP>_P<WP> i_write_address i_write_mask i_write_value

memory=selectorP<SIZEP> write_mask_not write_mask memory write_value



twiceAddressableMemoryP<SIZEP=1...24>_P<RP=0...10>_P<WP=0...10>:
<?(RP<SIZEP)>
<?(WP<SIZEP)>

o_read_value_a: out <2**RP>
o_read_value_b: out <2**RP>

i_read_address_a: in <SIZEP-RP>
i_read_address_b: in <SIZEP-RP>
i_write_mask_a: in <2**WP>
i_write_mask_b: in <2**WP>
i_write_address_a: in <SIZEP-WP>
i_write_address_b: in <SIZEP-WP>
i_write_value_a: in <2**WP>
i_write_value_b: in <2**WP>

memory: reg <2**SIZEP>

o_read_value_a=arrayIndexReadP<SIZEP>_P<RP> memory i_read_address_a
o_read_value_b=arrayIndexReadP<SIZEP>_P<RP> memory i_read_address_b

write_value_input_a=andP<WP> i_write_mask_a i_write_value_a
write_value_input_b=andP<WP> i_write_mask_b i_write_value_b

write_value_a write_value_a_not write_mask_a write_mask_a_not=arrayIndexWriteP<SIZEP>_P<WP> i_write_address_a i_write_mask_a write_value_input_a
write_value_b write_value_b_not write_mask_b write_mask_b_not=arrayIndexWriteP<SIZEP>_P<WP> i_write_address_b i_write_mask_b write_value_input_b

write_mask write_mask_not=ornor_negInputsP<SIZEP> write_mask_a_not write_mask_b_not
write_value write_value_not=ornor_negInputsP<SIZEP> write_value_a_not write_value_b_not

memory=selectorP<SIZEP> write_mask_not write_mask memory write_value



wordPairAddressableMemoryP<SIZEP=1...24>_P<RP=0...10>_P<WP=0...10>:
<?(RP<SIZEP)>
<?(WP<SIZEP)>

o_read_value: out <2**RP*2>

i_read_address: in <SIZEP-RP>
i_write_mask: in <2**WP*2>
i_write_address: in <SIZEP-WP>
i_write_value: in <2**WP*2>

read_address_b _=inc<SIZEP-RP> i_read_address 1
write_address_b _=inc<SIZEP-WP> i_write_address 1

write_a_mask=set<2**WP> i_write_mask[0:<2**WP>]
write_b_mask=set<2**WP> i_write_mask[<2**WP>:<2**WP*2>]
write_a=set<2**WP> i_write_value[0:<2**WP>]
write_b=set<2**WP> i_write_value[<2**WP>:<2**WP*2>]
oa ob=twiceAddressableMemoryP<SIZEP>_P<RP>_P<WP> i_read_address read_address_b write_a_mask write_b_mask i_write_address write_address_b write_a write_b
o_read_value=set<2**RP*2> oa+ob



multipleConsecutiveWordAddressableMemoryP<SIZEP=1...24>_P<WORDP=0...4>_readP<RCP=1...5>_writeP<WCP=1...5>:
<?(WORDP+RCP<SIZEP)>
<?(WORDP+WCP<SIZEP)>

o_read_value: out <2**(WORDP+RCP)>

i_read_address: in <SIZEP-WORDP>
i_write_mask: in <2**(WORDP+WCP)>
i_write_address: in <SIZEP-WORDP>
i_write_value: in <2**(WORDP+WCP)>

write_address_for_shift=concat<WCP>_1 i_write_address[0:<WCP>] 0

write_mask_pre_shift=concat<2**(WORDP+WCP)>_<2**(WORDP+WCP)> i_write_mask 0
write_mask=wordShiftLeftN_P<WCP+1>_wordP<WORDP> write_mask_pre_shift write_address_for_shift

write_value_pre_shift=concat<2**(WORDP+WCP)>_<2**(WORDP+WCP)> i_write_value 0
write_value=wordShiftLeftN_P<WCP+1>_wordP<WORDP> write_value_pre_shift write_address_for_shift

read_value_pre_shift=wordPairAddressableMemoryP<SIZEP>_P<WORDP+RCP>_P<WORDP+WCP> i_read_address[<RCP>:<SIZEP-WORDP>] write_mask i_write_address[<WCP>:<SIZEP-WORDP>] write_value

read_address_for_shift=concat<RCP>_1 i_read_address[0:<RCP>] 0

read_value=wordShiftRightUnsignedN_P<RCP+1>_wordP<WORDP> read_value_pre_shift read_address_for_shift
o_read_value=set<2**(WORDP+RCP)> read_value[0:<2**(WORDP+RCP)>]



addressableMemoryConsecutiveWords<ADDRESS=1...16>_<WORD=1,2,4,8,16>_<SEQ=2,4,8,16,32>:
<?(2**ADDRESS>SEQ*2)>

output: out <WORD*SEQ>

output_address: in <ADDRESS>
input_writeMask: in <SEQ>
input_address: in <ADDRESS>
input: in <WORD*SEQ>

writeMask=fanOutBitwiseP<log2(WORD)>_P<log2(SEQ)> input_writeMask
output=multipleConsecutiveWordAddressableMemoryP<ADDRESS+log2(WORD)>_P<log2(WORD)>_readP<log2(SEQ)>_writeP<log2(SEQ)> output_address writeMask input_address input



bitsSetUntil1:

o: out 2

i: in

o=concat1_1 i 0



bitsSetUntil<S=2...16>:

o: out <2**S>

i: in <S>

a=bitsSetUntil<S-1> i[0:<S-1>]
oa=ternaryOperatorP<S-1> i[<S-1>] a -1
ob=ternaryOperatorP<S-1> i[<S-1>] 0 a
o=set<2**S> oa+ob



arrayReadElementByIndexP<LENGTHP=1...16>_word<WORD=1,2,4,8,16>:

o: out <WORD>

i_array: in <2**LENGTHP*WORD>
i_index: in <LENGTHP>

arrays=set<2**LENGTHP*WORD> i_array%<WORD>
i_index_not=not*<LENGTHP> i_index
o=multiplexer<LENGTHP>_preComputedData*<WORD> i_index_not*<WORD> i_index*<WORD> arrays



computerStageShiftRegisterUpdate:

nextShiftRegisterValue: out 8

shiftRegisterValue: in 8
restart: in
moveForward: in

shifted _=bitShiftLeft1_8 shiftRegisterValue
a=chooseAB8 moveForward shiftRegisterValue shifted
nextShiftRegisterValue=chooseAB8 restart a 1



alu:

output: out 16

inputA: in 16
inputB: in 16
operationIndex: in 4

rNot=not*16 inputA
rNeg=neg16 inputA
rAnd=and*16 inputA inputB
rOr=or*16 inputA inputB
rXor=xor*16 inputA inputB
rShl _=bitShiftLeftN_P4 inputA inputB[0:4]
rShr _=bitShiftRightUnsignedN_P4 inputA inputB[0:4]
rShrs _=bitShiftRightSignedN_P4 inputA inputB[0:4]

rAdd _=add16 inputA inputB 0
rSub _=sub16 inputA inputB 0
rMul _=mul16_16 inputA inputB
rDiv rMod=divUnsigned16 inputA inputB
rDivs rMods=divSigned16 inputA inputB

a=chooseABCDEFGH16 operationIndex[0:3] rNot rNeg rAnd rOr rXor rShl rShr rShrs
b=chooseABCDEFGH16 operationIndex[0:3] rAdd rSub rMul 0 rDiv rDivs rMod rMods
output=chooseAB16 operationIndex[3] a b



getOpcodeValid:

valid: out

opcode: in 8

a=chooseABCDEFGH1 opcode[0:3] 1 1 1 1 1 1 1 1
b=chooseABCDEFGH1 opcode[0:3] 1 1 1 0 1 1 1 1
c=chooseABCDEFGH1 opcode[0:3] 1 1 1 1 1 1 1 1
d=chooseABCDEFGH1 opcode[0:3] 1 0 0 0 0 0 0 0
o=chooseABCD1 opcode[3:5] a b c d
insideRange=equal3 opcode[5:8] 0
valid=and insideRange o



getOpcodeFirstArgumentIsOutput:

output: out

valid: in
opcode: in 8

a=chooseABCDEFGH8 opcode[0:3] 1 1 1 1 1 1 1 1
b=chooseABCDEFGH8 opcode[0:3] 1 1 1 0 1 1 1 1
c=chooseABCDEFGH8 opcode[0:3] 1 0 0 0 0 0 0 0
d=chooseABCDEFGH8 opcode[0:3] 0 0 0 0 0 0 0 0
o=chooseABCD8 opcode[3:5] a b c d
output=chooseAB8 valid 0 o



getOpcodeParameterCount:

output: out 8

valid: in
opcode: in 8

a=chooseABCDEFGH8 opcode[0:3] 2 2 3 3 3 3 3 3
b=chooseABCDEFGH8 opcode[0:3] 3 3 3 0 3 3 3 3
c=chooseABCDEFGH8 opcode[0:3] 2 1 3 3 3 3 3 3
d=chooseABCDEFGH8 opcode[0:3] 1 0 0 0 0 0 0 0
o=chooseABCD8 opcode[3:5] a b c d
output=chooseAB8 valid 0 o



getOpcodeUseAlu:

useAlu: out

valid: in
opcode: in 8

insideRange=equal4 opcode[4:8] 0
useAlu=and valid insideRange



getOpcodeAluOperationIndex:

operationIndex: out 4

valid: in
opcode: in 8

operationIndex=chooseAB4 valid 0 opcode[0:4]



getOpcodeNotAluInstruction:

isMov: out
isJ: out
isJe: out
isJne: out
isJl: out
isJnl: out
isJls: out
isJnls: out
isOut: out

opcode: in 8

isMov=equal8 opcode 16
isJ=equal8 opcode 17
isJe=equal8 opcode 18
isJne=equal8 opcode 19
isJl=equal8 opcode 20
isJnl=equal8 opcode 21
isJls=equal8 opcode 22
isJnls=equal8 opcode 23
isOut=equal8 opcode 24



getOpcodeNotAluJumpInstruction:

isJ: out
isJe: out
isJne: out
isJl: out
isJnl: out
isJls: out
isJnls: out

opcode: in 8

isMov isJ isJe isJne isJl isJnl isJls isJnls isOut=getOpcodeNotAluInstruction opcode



getOpcodeNotAluNotJumpInstruction:

isMov: out
isOut: out

opcode: in 8

isMov isJ isJe isJne isJl isJnl isJls isJnls isOut=getOpcodeNotAluInstruction opcode



getInstructionJump:

executeJump: out
executeJump_address: out 16

enable: in
opcode: in 8
argumentA: in 16
argumentB: in 16
argumentC: in 16

isJ isJe isJne isJl isJnl isJls isJnls=getOpcodeNotAluJumpInstruction opcode

isJumpTypeInstruction=orABCDEFG isJ isJe isJne isJl isJnl isJls isJnls

_pre_acceptJe=equal16 argumentB argumentC
_pre_acceptJne=not _pre_acceptJe
_pre_acceptJl=lessThanUnsigned16 argumentB argumentC
_pre_acceptJnl=not _pre_acceptJl
_pre_acceptJls=lessThanSigned16 argumentB argumentC
_pre_acceptJnls=not _pre_acceptJls

acceptJe=and isJe _pre_acceptJe
acceptJne=and isJne _pre_acceptJne
acceptJl=and isJl _pre_acceptJl
acceptJnl=and isJnl _pre_acceptJnl
acceptJls=and isJls _pre_acceptJls
acceptJnls=and isJnls _pre_acceptJnls

acceptJump=orABCDEFG isJ acceptJe acceptJne acceptJl acceptJnl acceptJls acceptJnls
executeJump=andABC enable isJumpTypeInstruction acceptJump
executeJump_address=set16 argumentA



decodeParameter:

w: out
r: out
m: out
value: out 16

bytesValid: in
bytes: in 24

_w=set bytes[7]
_r=set bytes[6]
_m=set bytes[5]
_value_short=concat5_11 bytes[0:5] 0
_value_long=set16 bytes[8:24]

_value=chooseAB16 _w _value_short _value_long

w=chooseAB1 bytesValid 0 _w
r=chooseAB1 bytesValid 0 _r
m=chooseAB1 bytesValid 0 _m
value=chooseAB16 bytesValid 0 _value



decodeInstruction</B=8></E=16></MAX=24>:

o_instructionLength: out 16
o_instructionValid: out
o_parameterA_isOutput: out
o_opcode: out 8
o_parameters_R: out 8
o_parameters_M: out 8
o_parameterA: out 16
o_parameterB: out 16
o_parameterC: out 16

i_bytes: in 128

bytes=set128 i_bytes

opcode=set8 bytes[0:8]
opcodeValid=getOpcodeValid opcode
parameterCount=getOpcodeParameterCount opcodeValid opcode

parameters=bitsSetUntil2 parameterCount[0:2]


parameterA_bytes=set24 bytes[8:<8+MAX>]
parameterA_W parameterA_R parameterA_M parameterA_value=decodeParameter parameters[0] parameterA_bytes

parameterB_bytes=chooseAB24 parameterA_W bytes[<8+B>:<8+B+MAX>] bytes[<8+B+E>:<8+B+E+MAX>]
parameterB_W parameterB_R parameterB_M parameterB_value=decodeParameter parameters[1] parameterB_bytes

_justOneParameterW=xor parameterA_W parameterB_W
_bothParametersW=and parameterA_W parameterB_W
_parameterC_bytes_a=chooseAB24 _justOneParameterW bytes[<8+B*2>:<8+B*2+MAX>] bytes[<8+B*2+E>:<8+B*2+E+MAX>]
parameterC_bytes=chooseAB24 _bothParametersW _parameterC_bytes_a bytes[<8+B*2+E*2>:<8+B*2+E*2+MAX>]
parameterC_W parameterC_R parameterC_M parameterC_value=decodeParameter parameters[2] parameterC_bytes


_instructionLength_opcode_and_parameters _=inc4 parameterCount[0:4] 1

_w_count_0=concat1_3 parameterA_W 0
_w_count_1 _=inc4 _w_count_0 parameterB_W
_w_count _=inc4 _w_count_1 parameterC_W

_w_bytes _=bitShiftLeft<log2(E/8)>_4 _w_count

_instructionLength _=add4 _instructionLength_opcode_and_parameters _w_bytes 0

instructionLength=concat4_12 _instructionLength 0


parameterA_isOutput=getOpcodeFirstArgumentIsOutput opcodeValid opcode

_memoryInputs_B_or_C=or parameterB_M parameterC_M
_moreThanOneMemoryInput_a=andnot _memoryInputs_B_or_C parameterA_isOutput
moreThanOneMemoryInput=andorand parameterB_M parameterC_M parameterA_M _moreThanOneMemoryInput_a
atMostOneMemoryInput=not moreThanOneMemoryInput

parameterA_immediate=nor parameterA_R parameterA_M
invalidOutputParameters=and parameterA_isOutput parameterA_immediate
noInvalidOutputParameters=not invalidOutputParameters

instructionValid=andABC opcodeValid atMostOneMemoryInput noInvalidOutputParameters

parameters_R=set3 parameterA_R+parameterB_R+parameterC_R
parameters_M=set3 parameterA_M+parameterB_M+parameterC_M

o_instructionLength=set16 instructionLength
o_instructionValid=set instructionValid
o_parameterA_isOutput=set parameterA_isOutput
o_opcode=set8 opcode
o_parameters_R=concat3_5 parameters_R 0
o_parameters_M=concat3_5 parameters_M 0
o_parameterA=set16 parameterA_value
o_parameterB=set16 parameterB_value
o_parameterC=set16 parameterC_value



instructionBytesRegister:

o_bytes: out 128
o_bytes_updated: out 128

i_set: in
i_bytes: in 128

saved_bytes: reg 128

bytes=ternaryOperatorP7 i_set saved_bytes i_bytes
saved_bytes=set128 bytes

o_bytes=set128 saved_bytes
o_bytes_updated=set128 bytes



argumentLoader:

o_argument: out 16
o_readMemory: out
o_readMemory_address: out 16

i_canLoad: in
i_isOutput: in
i_R: in
i_M: in
i_parameter: in 16
i_registers: in 512
i_memory: in 16

saved_argument: reg 16

isOutput=set i_isOutput
isInput=not isOutput


argument_pre_register=set16 i_parameter
RM=and i_R i_M
readRegister=chooseAB1 isOutput i_R RM
readRegisterAddress=set5 argument_pre_register[0:5]
argument_pre_memory=chooseAB16 readRegister argument_pre_register register


register=arrayReadElementByIndexP5_word16 i_registers readRegisterAddress


readMemory=andABC i_canLoad i_M isInput
readMemoryAddress=set16 argument_pre_memory

memory=set16 i_memory
argument=chooseAB16 readMemory argument_pre_memory memory

saved_argument=chooseAB16 i_canLoad saved_argument argument

o_argument=set16 saved_argument
o_readMemory=set readMemory
o_readMemory_address=chooseAB16 readMemory 0 readMemoryAddress



argumentStorer:

o_registers_write_value: out 512
o_registers_write_mask: out 512
o_memory_write: out
o_memory_write_value: out 16
o_memory_write_address: out 16

i_store_enable: in
i_value: in 16
i_store_in_memory: in
i_store_address: in 16


storeInRegister=andnot i_store_enable i_store_in_memory
register_out=chooseAB16 storeInRegister 0 i_value
register_out_mask=chooseAB16 storeInRegister 0 -1

register_out_extended=concat16_496 register_out 0
register_out_mask_extended=concat16_496 register_out_mask 0

registers_write_value=wordShiftLeftN_P5_wordP4 register_out_extended i_store_address[0:5]
registers_write_mask=wordShiftLeftN_P5_wordP4 register_out_mask_extended i_store_address[0:5]


memory_write=and i_store_enable i_store_in_memory
memory_write_value=set16 i_value
memory_write_address=set16 i_store_address

o_registers_write_value=set512 registers_write_value
o_registers_write_mask=set512 registers_write_mask
o_memory_write=set memory_write
o_memory_write_value=set16 memory_write_value
o_memory_write_address=set16 memory_write_address



computerB<ADDRESS=6...16></MSEQ=16>:
<?(MSEQ>=10)>

output: out 16
outputEnable: out

input: in 8
inputCodeStop: in


registers: reg 512

registers_write_mask_not=notP9 registers_write_mask
registers=selectorP9 registers_write_mask_not registers_write_mask registers registers_write_value


loadInputCode_address: reg 16

loadInputCode=not executionStarted_next
loadInputCode_address _=inc16 loadInputCode_address loadInputCode
loadInputCode_value16=concat8_8 input 0


executionStarted: reg

executionStarted_next=or executionStarted inputCodeStop
executionStarted=set executionStarted_next


executionIsGoingToStartAtNextCycle=andnot executionStarted_next executionStarted

endOfInstruction=or ignoreInstruction instructionExecutionEnd
instructionStage_moveForward=or instructionStage_decode instructionStage_loadArguments

instructionStage: reg 8

startInstruction=or executionIsGoingToStartAtNextCycle endOfInstruction
instructionStage=computerStageShiftRegisterUpdate instructionStage startInstruction instructionStage_moveForward


instructionStage_decode=and executionStarted instructionStage[0]
instructionStage_loadArguments=and executionStarted instructionStage[1]
instructionStage_execute=and executionStarted instructionStage[2]


instructionBytes instructionBytesUpdated=instructionBytesRegister instructionStage_decode memoryRead_value

instructionLength instructionValid _ _ _ _ _ _ _=decodeInstruction instructionBytesUpdated
_ _ parameterA_isOutput opcode parameters_R parameters_M parameterA parameterB parameterC=decodeInstruction instructionBytes


ignoreInstruction=andnot executionStarted instructionValid


argumentA _memoryA _memoryA_address=argumentLoader instructionStage_loadArguments parameterA_isOutput parameters_R[0] parameters_M[0] parameterA registers memoryRead_value16
argumentB _memoryB _memoryB_address=argumentLoader instructionStage_loadArguments 0 parameters_R[1] parameters_M[1] parameterB registers memoryRead_value16
argumentC _memoryC _memoryC_address=argumentLoader instructionStage_loadArguments 0 parameters_R[2] parameters_M[2] parameterC registers memoryRead_value16

_memoryRead=orABC _memoryA _memoryB _memoryC
_memoryRead_address=orABC16 _memoryA_address _memoryB_address _memoryC_address


aluOperationIndex=getOpcodeAluOperationIndex instructionValid opcode
aluOutput=alu argumentB argumentC aluOperationIndex[0:4]
isAluInstruction=getOpcodeUseAlu instructionValid opcode

instructionOperationResult=chooseAB16 isAluInstruction argumentB aluOutput

storeResult=and instructionStage_execute parameterA_isOutput
registers_write_value registers_write_mask memory_write memory_write_value memory_write_address=argumentStorer storeResult instructionOperationResult parameters_M[0] argumentA


executeJump executeJump_address=getInstructionJump instructionStage_execute opcode argumentA argumentB argumentC

isMov isOut=getOpcodeNotAluNotJumpInstruction opcode

_outputEnable=and instructionStage_execute isOut
_output=chooseAB16 _outputEnable 0 argumentA

outputEnable=set _outputEnable
output=set16 _output


instructionExecutionEnd=set instructionStage_execute


nextInstructionStartAddress _=add16 codeAddressRegister instructionLength 0


codeAddressRegister: reg 16

codeAddressRegister_change=set endOfInstruction
codeAddressRegister_change_value=chooseAB16 executeJump nextInstructionStartAddress executeJump_address
codeAddressRegister=chooseAB16 codeAddressRegister_change codeAddressRegister codeAddressRegister_change_value


_memoryWrite_mask2_a=chooseAB2 memory_write 0 3
memoryWrite_mask2=chooseAB2 loadInputCode _memoryWrite_mask2_a 1
memoryWrite_value16=chooseAB16 loadInputCode memory_write_value loadInputCode_value16

memoryRead_address=chooseAB16 _memoryRead codeAddressRegister _memoryRead_address
memoryWrite_mask=concat2_<MSEQ-2> memoryWrite_mask2 0
memoryWrite_address=chooseAB16 loadInputCode memory_write_address loadInputCode_address
memoryWrite_value=concat16_<8*MSEQ-16> memoryWrite_value16 0

memoryRead_value=addressableMemoryConsecutiveWords<ADDRESS>_8_<MSEQ> memoryRead_address[0:<ADDRESS>] memoryWrite_mask memoryWrite_address[0:<ADDRESS>] memoryWrite_value

memoryRead_value16=set16 memoryRead_value[0:16]



memoryTest<ADDRESS=6...16></MSEQ=16>:

output: out 16
outputEnable: out

input: in 8
inputCodeStop: in

counter: reg 16
empty_reg: reg 48

empty_reg=set48 empty_reg

counter _=inc16 counter 1

memoryRead_address=concat1_15 0 counter[0:15]
memoryWrite_mask=set<MSEQ> 3
memoryWrite_address=concat1_15 0 counter[0:15]
memoryWrite_value=concat16_<MSEQ*8-16> counter 0

memoryRead_value=addressableMemoryConsecutiveWords<ADDRESS>_8_<MSEQ> memoryRead_address[0:<ADDRESS>] memoryWrite_mask memoryWrite_address[0:<ADDRESS>] memoryWrite_value

output=set16 memoryRead_value[0:16]
outputEnable=set 1



memoryTestB<ADDRESS=6...16></WORD=2>:

output: out 16
outputEnable: out

input: in 8
inputCodeStop: in

counter: reg 16
empty_reg: reg 48

empty_reg=set48 empty_reg

counter _=inc16 counter 1

memoryRead_address=set16 counter
memoryWrite_mask=set16 -1
memoryWrite_address=set16 counter
memoryWrite_value=set16 counter

memoryRead_value=addressableMemoryP<ADDRESS+log2(WORD*8)>_P<log2(WORD*8)>_P<log2(WORD*8)> memoryRead_address[0:<ADDRESS>] memoryWrite_mask memoryWrite_address[0:<ADDRESS>] memoryWrite_value

output=set16 memoryRead_value
outputEnable=set 1



main:

output: out 16
outputEnable: out

input: in 8
inputCodeStop: in

output outputEnable=computerB8 input inputCodeStop
