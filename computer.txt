<NAME=not>1:

output: out
input: in

output=<NAME> input



<NAME=not><N=2...16>:

output: out <N>
input: in <N>

a=<NAME><N-1> input[0:<N-1>]
b=<NAME>1 input[<N-1>]
output=concat<N-1>_1 a b



<NAME=and,or,xor>1:

output: out
inputA: in
inputB: in

output=<NAME> inputA inputB



<NAME=and,or,xor><N=2...16>:

output: out <N>
inputA: in <N>
inputB: in <N>

a=<NAME><N-1> inputA[0:<N-1>] inputB[0:<N-1>]
b=<NAME>1 inputA[<N-1>] inputB[<N-1>]
output=concat<N-1>_1 a b



<NAME=andABC,orABC,xorABC>1:

output: out
inputA: in
inputB: in
inputC: in

output=<NAME> inputA inputB inputC



<NAME=andABC,orABC,xorABC><N=2...16>:

output: out <N>
inputA: in <N>
inputB: in <N>
inputC: in <N>

a=<NAME><N-1> inputA[0:<N-1>] inputB[0:<N-1>] inputC[0:<N-1>]
b=<NAME>1 inputA[<N-1>] inputB[<N-1>] inputC[<N-1>]
output=concat<N-1>_1 a b



not:

output: out
input: in

output=nand input input



and:

output: out
inputA: in
inputB: in

a=nand inputA inputB
output=not a



or:

output: out
inputA: in
inputB: in

a=not inputA
b=not inputB
output=nand a b



xor:

output: out
inputA: in
inputB: in

a=or inputA inputB
b=nand inputA inputB
output=and a b



<NAME=and,or,xor>ABC:

output: out

inputA: in
inputB: in
inputC: in

a=<NAME> inputA inputB
output=<NAME> a inputC



add:

output: out
outputCarry: out

inputA: in
inputB: in
inputC: in

output=xorABC inputA inputB inputC

a=not inputA
b=andABC a inputB inputC
c=or inputB inputC
d=and inputA c
outputCarry=or b d



add1:

output: out
outputCarry: out

inputA: in
inputB: in
inputC: in

output outputCarry=add inputA inputB inputC



add<N=2...16>:

output: out <N>
outputCarry: out

inputA: in <N>
inputB: in <N>
inputCarry: in

a carry=add<N-1> inputA[0:<N-1>] inputB[0:<N-1>] inputCarry
b outputCarry=add1 inputA[<N-1>] inputB[<N-1>] carry
output=concat<N-1>_1 a b



fanOutP0:

output: out
input: in

output=set input



fanOutP<N=1...16>:

output: out <2**N>

input: in

a=fanOutP<N-1> input
b=fanOutP<N-1> input
output=concat<2**N/2>_<2**N/2> a b



multiplexer:

output: out

inputControl: in
inputA: in
inputB: in

inputControlNot=not inputControl
a=nand inputControlNot inputA
b=nand inputControl inputB
output=nand a b



demultiplexer:

outputA: out
outputB: out

inputControl: in
input: in

inputControlNot=not inputControl
outputA=and inputControlNot input
outputB=and inputControl input



demultiplexer1:

output: out 2

inputControl: in
input: in

a b=demultiplexer inputControl input
output=concat1_1 a b



demultiplexer<N=2...16>:

output: out <2**N>

inputControl: in <N>
input: in

ia ib=demultiplexer inputControl[<N-1>] input
a=demultiplexer<N-1> inputControl[0:<N-1>] ia
b=demultiplexer<N-1> inputControl[0:<N-1>] ib
output=concat<2**N/2>_<2**N/2> a b



multiplexerArrayP0:

output: out

inputControl: in
inputA: in
inputB: in

output=multiplexer inputControl inputA inputB



multiplexerArrayP<N=1...16>:

output: out <2**N>

inputControl: in <2**N>
inputA: in <2**N>
inputB: in <2**N>

a=multiplexerArrayP<N-1> inputControl[0:<2**N/2>] inputA[0:<2**N/2>] inputB[0:<2**N/2>]
b=multiplexerArrayP<N-1> inputControl[<2**N/2>:<2**N>] inputA[<2**N/2>:<2**N>] inputB[<2**N/2>:<2**N>]
output=concat<2**N/2>_<2**N/2> a b



multiplexer1:

output: out

inputControl: in
input: in 2

output=multiplexer inputControl input[0] input[1]



multiplexer<N=2...16>:

output: out

inputControl: in <N>
input: in <2**N>

a=multiplexer<N-1> inputControl[0:<N-1>] input[0:<2**N/2>]
b=multiplexer<N-1> inputControl[0:<N-1>] input[<2**N/2>:<2**N>]
output=multiplexer inputControl[<N-1>] a b



addressableMemory<N=2...16>_1:

output: out

addressForOutput: in <N>
inputEnable: in
addressForInput: in <N>
input: in

memory: reg <2**N>

output=multiplexer<N> addressForOutput memory
memoryChange=demultiplexer<N> addressForInput inputEnable
inputFannedOut=fanOutP<N> input
memory=multiplexerArrayP<N> memoryChange memory inputFannedOut



addressableMemory<ADDRESS=2...16>_<WORD=2,4,8,16>:

output: out <WORD>

addressForOutput: in <ADDRESS>
inputEnable: in
addressForInput: in <ADDRESS>
input: in <WORD>

a=addressableMemory<ADDRESS>_<WORD/2> addressForOutput inputEnable addressForInput input[0:<WORD/2>]
b=addressableMemory<ADDRESS>_<WORD/2> addressForOutput inputEnable addressForInput input[<WORD/2>:<WORD>]
output=concat<WORD/2>_<WORD/2> a b



test:

output: out

input: in

b=set8 0
c=set 0
a=addressableMemory8_16 b c b a

output outputB=demultiplexer 0 1



main:

output: out 16
outputEnable: out

input: in 16

valueReg: reg 16


valueReg outputCarry=add16 input valueReg 0

inputPlusSomething inputPlusSomethingCarry=add16 input 4 0
output=addressableMemory8_16 input[0:8] 1 inputPlusSomething[0:8] input

outputEnable=test 0
